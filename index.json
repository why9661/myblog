[{"categories":["algorithm"],"content":"FIFO FIFO即\u0026quot;First In First Out\u0026quot;先进先出，淘汰缓存中“最老”的数据。\n实现：维护一个队列，新增记录添加到队尾，内存不够时淘汰队首。\nLFU LFU即“Least Frequently Used”最少使用，淘汰缓存中访问频率最低的数据。\n实现：LFU 的实现需要维护一个按照访问次数排序的队列，每次访问，访问次数加1，队列重新排序，淘汰时选择访问次数最少的即可。\nLRU LRU即“Least Recently Used”即最近最少使用。\n实现：LRU 算法的实现非常简单，维护一个队列，如果某条记录被访问了，则移动到队尾，那么队首则是最近最少访问的数据，淘汰该条记录即可。\nGolang实现\n1package lru 2 3import \u0026#34;container/list\u0026#34; 4 5type Lru struct { 6 mBytes int64 // max memory allowed 7 nbytes int64 // used memory 8 queue *list.List // double linked list 9 cache map[string]*list.Element // k-v map 10 OnEvicted func(key string, value Value) //callback function executed when an entry is purged 11} 12 13type entry struct { 14 key string 15 value Value 16} 17 18type Value interface { 19 Len() int 20} 21 22func New(mBytes int64, onEvicted func(string, Value)) *Lru { 23 return \u0026amp;Lru{ 24 mBytes: mBytes, 25 queue: list.New(), 26 cache: make(map[string]*list.Element), 27 OnEvicted: onEvicted, 28 } 29} 30 31// Get looks up a key\u0026#39;s value from the cache 32func (l *Lru) Get(key string) (value Value, ok bool) { 33 if l.cache == nil { 34 return 35 } 36 if ele, ok := l.cache[key]; ok { 37 value = ele.Value.(*entry).value 38 l.queue.MoveToFront(ele) 39 return value, true 40 } 41 return 42} 43 44//Remove removes key\u0026#39;s value from the cache 45func (l *Lru) Remove(key string) { 46 if l.cache == nil { 47 return 48 } 49 if ele, ok := l.cache[key]; ok { 50 l.RemoveElement(ele) 51 } 52} 53 54func (l *Lru) RemoveElement(ele *list.Element) { 55 e := ele.Value.(*entry) 56 delete(l.cache, e.key) 57 l.queue.Remove(ele) 58 l.nbytes -= int64(len(e.key)) + int64(e.value.Len()) 59 if l.OnEvicted != nil { 60 l.OnEvicted(e.key, e.value) 61 } 62} 63 64//RemoveOldest removes the oldest item from the cache 65func (l *Lru) RemoveOldest() { 66 ele := l.queue.Back() 67 if ele != nil { 68 e := ele.Value.(*entry) 69 delete(l.cache, e.key) 70 l.queue.Remove(ele) 71 l.nbytes -= int64(len(e.key)) + int64(e.value.Len()) 72 if l.OnEvicted != nil { 73 l.OnEvicted(e.key, e.value) 74 } 75 } 76} 77 78//Add adds a value to the cache (or update the provided key\u0026#39;s value) 79func (l *Lru) Add(key string, value Value) { 80 if ele, ok := l.cache[key]; ok { 81 l.queue.MoveToFront(ele) 82 e := ele.Value.(*entry) 83 l.nbytes += int64(value.Len()) - int64(e.value.Len()) 84 e.value = value 85 } else { 86 ele := l.queue.PushFront(\u0026amp;entry{key: key, value: value}) 87 l.cache[key] = ele 88 l.nbytes += int64(len(key)) + int64(value.Len()) 89 } 90 for l.nbytes \u0026gt; l.mBytes { 91 l.RemoveOldest() 92 } 93} 94 95//Len returns the number of items in the cache 96func (l *Lru) Len() int { 97 return l.queue.Len() 98} ","date":"2021-07-16","permalink":"https://why9661.github.io/myblog/posts/algorithm/lru/","series":null,"tags":["缓存淘汰策略"],"title":"Lru"},{"categories":["algorithm"],"content":"为什么要使用一致性哈希？\n普通的基于模运算的哈希算法会因为节点数目的变化而容易引起缓存雪崩（缓存在同一时刻全部失效，造成瞬时DB请求量大，压力骤增）。\n一致性哈希算法将 key 和节点映射到 2^32 的空间中，将这个数字首尾相连，形成一个环。\n①计算节点/机器(通常使用节点的名称、编号和 IP 地址)的哈希值，放置在环上。\n②计算key的哈希值放置在环上，顺时针寻找到的第一个节点，就是应选取的节点/机器。\n对于一致性哈希可能产生的数据倾斜的问题，可以引入“虚拟节点”：\n1、将虚拟节点的哈希值映射在环上\n2、计算key的哈希值，在环上顺时针寻找到应选取的虚拟节点\n3、通过虚拟节点映射到真实节点\n1package consistenthash 2 3import ( 4\t\u0026#34;hash/crc32\u0026#34; 5\t\u0026#34;sort\u0026#34; 6\t\u0026#34;strconv\u0026#34; 7) 8 9type hash func(data []byte) uint32 10 11type CHash struct { 12\thash hash 13\treplicas int //the number of virtual nodes 14\tkeys []int 15\tvrMap map[int]string //mapping: virtual node-real node 16} 17 18func NewCHash(replicas int, hashFunc hash) *CHash { 19\tcHash := CHash{ 20\thash: hashFunc, 21\treplicas: replicas, 22\tvrMap: make(map[int]string), 23\t} 24 25\tif cHash.hash == nil { 26\tcHash.hash = crc32.ChecksumIEEE 27\t} 28 29\treturn \u0026amp;cHash 30} 31 32func (ch *CHash) Add(keys ...string) { 33\tfor _, key := range keys { 34\tfor i := 0; i \u0026lt; ch.replicas; i++ { 35\thashData := []byte(strconv.Itoa(i) + key) 36\thash := int(ch.hash(hashData)) 37\tch.keys = append(ch.keys, hash) 38\tch.vrMap[hash] = key 39\t} 40\t} 41 42\tsort.Ints(ch.keys) 43} 44 45func (ch *CHash) Get(key string) string { 46\tif ch.keys == nil { 47\treturn \u0026#34;\u0026#34; 48\t} 49 50\thash := int(ch.hash([]byte(key))) 51\tindex := sort.Search(len(ch.keys), func(i int) bool { 52\treturn ch.keys[i] \u0026gt;= hash 53\t}) 54 55\treturn ch.vrMap[ch.keys[index%len(ch.keys)]] 56} ","date":"2020-09-11","permalink":"https://why9661.github.io/myblog/posts/algorithm/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/","series":null,"tags":["负载均衡"],"title":"一致性哈希"},{"categories":["algorithm"],"content":"普通轮询 1package roundrobin 2 3type RoundRobin struct { 4 curIndex int 5 nodes []string 6} 7 8func NewRoundRobin() *RoundRobin { 9 return \u0026amp;RoundRobin{} 10} 11 12func (rrb *RoundRobin) Add(keys ...string) { 13 for _, key := range keys { 14 rrb.nodes = append(rrb.nodes, key) 15 } 16} 17 18func (rrb *RoundRobin) Get() string { 19 rrb.curIndex++ 20 rrb.curIndex = rrb.curIndex % len(rrb.nodes) 21 return rrb.nodes[rrb.curIndex] 22} 平滑加权轮询 每个节点有3种权重：\nWeight：配置权重\nCurrentWeight：当前权重\nEffectiveWeight：有效权重\n初始化一个节点时配置权重=当前权重=有效权重\nTotalWeight：所有节点的总权重（有效权重）\n算法步骤：\n1、遍历所有节点，设置当前节点的CurrentWeight=CurrentWeight+EffectiveWegiht\n2、选取CurrentWeight最大的节点。\n2、被选取的节点CurrentWeight=CurrentWeight-TotalWeight\n在遍历过程中计算出TotalWeight\n1package weightroundrobin 2 3type WeightRoundRobin struct { 4 nodes []*Node 5} 6 7type Node struct { 8 weight int 9 curWeight int 10 effectiveWeight int 11 key string 12} 13 14func NewWeightRoundRobin() *WeightRoundRobin { 15 return \u0026amp;WeightRoundRobin{} 16} 17 18func newNode(key string, weight int) *Node { 19 node := Node{ 20 weight: weight, 21 curWeight: weight, 22 effectiveWeight: weight, 23 key: key, 24 } 25 26 return \u0026amp;node 27} 28 29func (wrrb *WeightRoundRobin) Add(key string, weight int) { 30 node := newNode(key, weight) 31 32 wrrb.nodes = append(wrrb.nodes, node) 33} 34 35func (wrrb *WeightRoundRobin) Get() string { 36 totalWeight := 0 37 38 var maxCurWeightNode *Node 39 40 for _, node := range wrrb.nodes { 41 totalWeight += node.effectiveWeight 42 43 node.curWeight += node.effectiveWeight 44 45 if maxCurWeightNode == nil || node.curWeight \u0026gt; maxCurWeightNode.curWeight { 46 maxCurWeightNode = node 47 } 48 } 49 50 maxCurWeightNode.curWeight -= totalWeight 51 52 return maxCurWeightNode.key 53} ","date":"2020-09-02","permalink":"https://why9661.github.io/myblog/posts/algorithm/%E8%BD%AE%E8%AF%A2/","series":null,"tags":["负载均衡"],"title":"轮询"}]