[{"categories":["algorithm"],"content":"FIFO FIFO即\u0026quot;First In First Out\u0026quot;先进先出，淘汰缓存中“最老”的数据。\n实现：维护一个队列，新增记录添加到队尾，内存不够时淘汰队首。\nLFU LFU即“Least Frequently Used”最少使用，淘汰缓存中访问频率最低的数据。\n实现：LFU 的实现需要维护一个按照访问次数排序的队列，每次访问，访问次数加1，队列重新排序，淘汰时选择访问次数最少的即可。\nLRU LRU即“Least Recently Used”即最近最少使用。\n实现：LRU 算法的实现非常简单，维护一个队列，如果某条记录被访问了，则移动到队尾，那么队首则是最近最少访问的数据，淘汰该条记录即可。\nGolang实现\n1package lru 2 3import \u0026#34;container/list\u0026#34; 4 5type Lru struct { 6 mBytes int64 // max memory allowed 7 nbytes int64 // used memory 8 queue *list.List // double linked list 9 cache map[string]*list.Element // k-v map 10 OnEvicted func(key string, value Value) //callback function executed when an entry is purged 11} 12 13type entry struct { 14 key string 15 value Value 16} 17 18type Value interface { 19 Len() int 20} 21 22func New(mBytes int64, onEvicted func(string, Value)) *Lru { 23 return \u0026amp;Lru{ 24 mBytes: mBytes, 25 queue: list.New(), 26 cache: make(map[string]*list.Element), 27 OnEvicted: onEvicted, 28 } 29} 30 31// Get looks up a key\u0026#39;s value from the cache 32func (l *Lru) Get(key string) (value Value, ok bool) { 33 if l.cache == nil { 34 return 35 } 36 if ele, ok := l.cache[key]; ok { 37 value = ele.Value.(*entry).value 38 l.queue.MoveToFront(ele) 39 return value, true 40 } 41 return 42} 43 44//Remove removes key\u0026#39;s value from the cache 45func (l *Lru) Remove(key string) { 46 if l.cache == nil { 47 return 48 } 49 if ele, ok := l.cache[key]; ok { 50 l.RemoveElement(ele) 51 } 52} 53 54func (l *Lru) RemoveElement(ele *list.Element) { 55 e := ele.Value.(*entry) 56 delete(l.cache, e.key) 57 l.queue.Remove(ele) 58 l.nbytes -= int64(len(e.key)) + int64(e.value.Len()) 59 if l.OnEvicted != nil { 60 l.OnEvicted(e.key, e.value) 61 } 62} 63 64//RemoveOldest removes the oldest item from the cache 65func (l *Lru) RemoveOldest() { 66 ele := l.queue.Back() 67 if ele != nil { 68 e := ele.Value.(*entry) 69 delete(l.cache, e.key) 70 l.queue.Remove(ele) 71 l.nbytes -= int64(len(e.key)) + int64(e.value.Len()) 72 if l.OnEvicted != nil { 73 l.OnEvicted(e.key, e.value) 74 } 75 } 76} 77 78//Add adds a value to the cache (or update the provided key\u0026#39;s value) 79func (l *Lru) Add(key string, value Value) { 80 if ele, ok := l.cache[key]; ok { 81 l.queue.MoveToFront(ele) 82 e := ele.Value.(*entry) 83 l.nbytes += int64(value.Len()) - int64(e.value.Len()) 84 e.value = value 85 } else { 86 ele := l.queue.PushFront(\u0026amp;entry{key: key, value: value}) 87 l.cache[key] = ele 88 l.nbytes += int64(len(key)) + int64(value.Len()) 89 } 90 for l.nbytes \u0026gt; l.mBytes { 91 l.RemoveOldest() 92 } 93} 94 95//Len returns the number of items in the cache 96func (l *Lru) Len() int { 97 return l.queue.Len() 98} ","date":"2021-07-16","permalink":"https://why9661.github.io/myblog/posts/algorithm/lru/","series":null,"tags":["缓存淘汰策略"],"title":"Lru"},{"categories":["Docker"],"content":"安装 https://docs.docker.com/engine/install/centos/\r配置镜像加速\n①修改配置文件\n  vim /etc/docker/daemon.json\n  1{ 2 \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;http://hub-mirror.c.163.com\u0026#34;] 3}   systemctl daemon-reload\nsystemctl restart docker\n  ②修改docker服务启动脚本\n vim /usr/lib/systemd/system/docker.service  简介 虚拟机vs容器 虚拟机是在宿主机上虚拟一个OS，所以虚拟机的运行需要消耗很多系统内存和CPU，这样不可避免的就同应用程序争抢资源，而容器化的应用是直接运行在宿主机上的和宿主机共享内核，基本上无需额外的CPU和内存消耗。\n虚拟机上的应用同宿主机进行IO等交互时由于需要经过虚拟机这个中间介质，所以IO效率相比容器就会低很多。\n隔离\u0026amp;资源限制 docker使用linux内核的namespace、cgroups机制来实现容器之间的隔离和资源限制的。\nnamespace namespace主要有PID namespace、 挂载点信息隔离的Mount namespace、 隔离网络资源的Network namespace、隔离用户的User namespace等。\ncgroup CGroup技术是用来限制单个进程对CPU、内存、磁盘等资源的占用，Docker通过cgroup限制docker启动的进程对以上资源的消耗。\nCPU相关的限制\n  \u0026ndash;cpus decimal\n限制容器使用的cpu数量\n  \u0026ndash;cpuset-cpus string\n限制容器在某个（可以多个）cpu上运行\n  \u0026ndash;cpu-shares int\n设置使用cpu的权重（当 cpu资源充足时，设置 cpu的权重是没有意义的。只有在容器争用 cpu资源的情况下， cpu的权重才能让不同的容器分到不同的 cpu用量）\n  内存相关的限制\n  -m(\u0026ndash;memory) bytes\n限制容器可以使用的最大内存\n  \u0026ndash;memory-swap bytes\n限制容器可以使用的swap大小（实际表示的是memory和swap之和！）\n必须和\u0026ndash;memory一起使用\n  Dockerfile 注释使用#\nFROM 指定基础镜像，在这个基础镜像之上进行修改定制。\n必须为第一个命令。\nDocker 还有一个特殊的镜像 scratch，这个镜像是虚拟的，表示空白镜像。\nLABEL 通常用于指定镜像制作者的信息以及其它的一些描述信息\nENV 设置环境变量\nENV WORKDIR WORKDIR 用来切换工作目录。Docker 默认的工作目录是/，只有 RUN 能执行 cd 命令切换目录，而且还只作用在当下的 RUN。如果想让其他指令在指定的目录下执行，就得靠 WORKDIR。\nWORKDIR 动作的目录改变是持久的，不用每个指令前都使用一次 WORKDIR。\nRUN 构建镜像时（docker build）执行的命令。\nRUN的默认权限是sudo。 需要注意的是，如果你需要执行多个RUN操作，那最好把它们合并在一行 (用\u0026amp;\u0026amp;连接)，因为每执行一次RUN就会在docker上新建一层镜像，所以分开来写很多个RUN的结果就是会导致整个镜像无意义的过大膨胀。\nCMD 与RUN不同，CMD是创建容器时（docker run）所执行的命令。\nDockerfile中只能设置一个CMD，如果设置多个，那么生效的是最后一个。\nCMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。\nCMD [\u0026ldquo;操作\u0026rdquo;，\u0026ldquo;参数1\u0026rdquo;，”参数2“]\nENTRYPOINT 与CMD非常类似，不同的是通过docker run执行的命令不会覆盖ENTRYPOINT。\nENTRYPOINT[”操作“，“参数1”，“参数2”]\nADD 从上下文目录中复制文件或者目录到容器里指定路径，tar类型会自动解压。\n可以访问网络资源（类似wget）\nCOPY 从上下文目录中复制文件或者目录到容器里指定路径，功能类似ADD，但是不会自动解压，也不能访问网络资源。\nEXPOSE 声明运行时容器提供的服务端口，这只是一个声明，并不会自动在宿主进行端口映射。\n常用命令 监控容器资源消耗 docker stats\n镜像 docker build 根据Dockerfile创建镜像\n\u0026ndash;file -f 指定Dockerfile，默认是当前路径下的Dockerfile\n\u0026ndash;tag -t 设置镜像名称和版本 name:tag\n.代表本次执行的上下文路径\n上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。\n解析：由于 docker 的运行模式是 C/S。我们本机是 C，docker 引擎是 S。实际的构建过程是在 docker 引擎下完成的，所以这个时候无法用到我们本机的文件。这就需要把我们本机的指定目录下的文件一起打包提供给 docker 引擎使用。\neg: docker build -t myapp:v1.0.0 .\ndocker commit 根据容器创建镜像\n-a 作者\n-m 描述\neg: docker commit -a \u0026ldquo;WHY\u0026rdquo; -m \u0026ldquo;centos7 with golang\u0026rdquo; mycontainer（容器名） mycentos:V1.0（镜像名）\ndocker images 查看本地镜像\ndocker rmi 删除镜像\neg: docker rmi xxxxxxx\ndocker image prune 删除所有未使用镜像\ndocker pull 从镜像仓库拉取或更新指定镜像\neg: docker pull redis\ndocker search 搜索镜像\neg：docker search golang\ndocker inspect 获取镜像/容器的元数据\ndocker save 保存镜像（将镜像打包成tar）\neg: docker save -o /root/helloweb.tar helloweb:v1.0\ndocker load 导入镜像\neg: docker load -i helloweb.tar\n容器 docker rm 删除容器\neg: docker rm xxxxxx\ndocker container prune 删除所有非运行状态的容器\ndocker ps 查看（运行中的）容器\n-a 查看所有容器\ndocker update 更新一些配置\ndocker run 创建容器\n\u0026ndash;name 指定容器名字\n-e 设置环境变量\n-h 指定容器的主机名\n-d 创建一个守护式容器在后台运行\n-p 指定容器暴露的端口 （将容器的端口映射到宿主机） 宿主机端口:容器端口\n-P 随机选取宿主机端口与容器内暴露的端口映射\n-i 表示以交互方式运行容器\n-t 容器启动后进入其命令行（为容器重新分配一个伪终端）\n  容器重启策略\n\u0026ndash;restart\n①no 默认策略，在容器退出时不重启\n②always 容器退出时总是重启\n③on-failure\n④on-failure:3\n⑤unless-stopped\n  目录挂载（数据卷操作）\n-v\n在创建容器的时候，可以将宿主机目录与容器内目录进行映射，从而达到持久化的目的。\n①指定目录挂载 -v 宿主机目录:容器目录\n②匿名挂载 -v 容器目录 （会存在宿主机的/var/lib/docker/volumes下）\n③具名挂载 -v 数据卷名:容器目录 （相对于匿名挂载，相当于给数据卷起了个名）\n④只读或读写 -v 宿主机目录:容器目录:ro/rw（默认读写rw） （容器不能写这个目录）\n⑤继承 \u0026ndash;volumes-from\n  \u0026ndash;rm参数\n当容器退出时自动删除容器，释放资源。可用与单元测试或压力测试\n  docker exec 进入容器\neg： docker exec -it mycontainer /bin/bash（要执行的命令，这里是打开bash）\ndocker start 启动容器\neg: docker start mycontainer01\ndocker stop 停止容器\neg: docker stop mycontainer01\ndocker kill 直接kill掉一个容器\ndocker cp 将文件拷贝到容器，或将容器中的文件拷贝到宿主机\ndocker cp 需要拷贝的文件或目录 容器名称：容器目录\ndocker cp 容器名称：容器目录 需要拷贝的文件或目录\ndocker logs 查看容器的日志\ndocker rename 容器重命名\n仓库 公共仓库 Docker Hub\n  docker login\t登录\n  docker tag 给image打标签\n  docker push 推送image\n  docker logout 退出\n  eg:\ndocker tag hello-world:latest hywong1996/hello-world-test:v1.0\ndocker push hywong1996/hello-world-test:v1.0\n注意：打标签时要改到自己的账户名下（hywong1996），否则会出错\n私有仓库   docker pull registry （用于搭建私有仓库的镜像）\n  修改配置文件\n/etc/docker/daemon.json\n添加\u0026quot;insecure-registries\u0026quot;:[\u0026ldquo;地址:5000\u0026rdquo;]\n  重新加载配置文件\nsystemctl daemon-reload\n  重新启动docker\nsystemctl restart docker\n  创建私有仓库容器\ndocker run \u0026ndash;name registry -id -p 5000:5000 registry\n  验证\n地址:5000/v2/_catalog\n  docker tag\n  docker pull\n  注意：如果出现”http: server gave HTTP response to HTTPS client“这个问题\nsystemctl enable docker.service\n修改 /usr/lib/systemd/system/docker.service 中的 ExecStart 选项，加入\u0026ndash;insecure-registry 地址:5000\nsystemctl daemon-reload\nsystemctl restart docker\n网络  docker network  bridge模式（默认） Docker守护进程会在宿主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。\n从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。在主机上创建一对虚拟网卡veth pair设备，Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0（容器的网卡），另一端放在主机中，以vethxxx这样类似的名字命名，并将这个网络设备加入到docker0网桥中。\nhost模式 docker run \u0026ndash;network host\n如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。\ncontainer模式 docker run \u0026ndash;network container:容器\n这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。\nnone模式 docuer run \u0026ndash;network none\n使用none模式，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。\n自定义网络 docker network create\ndocker daemon 实现了一个内嵌的DNS Server，但是只能在自定义网络中使用，这样就可以通过容器名进行通信。\n","date":"2021-05-02","permalink":"https://why9661.github.io/myblog/posts/docker/docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","series":null,"tags":["容器化"],"title":"Docker基本使用"},{"categories":["algorithm"],"content":"为什么要使用一致性哈希？\n普通的基于模运算的哈希算法会因为节点数目的变化而容易引起缓存雪崩（缓存在同一时刻全部失效，造成瞬时DB请求量大，压力骤增）。\n一致性哈希算法将 key 和节点映射到 2^32 的空间中，将这个数字首尾相连，形成一个环。\n①计算节点/机器(通常使用节点的名称、编号和 IP 地址)的哈希值，放置在环上。\n②计算key的哈希值放置在环上，顺时针寻找到的第一个节点，就是应选取的节点/机器。\n对于一致性哈希可能产生的数据倾斜的问题，可以引入“虚拟节点”：\n1、将虚拟节点的哈希值映射在环上\n2、计算key的哈希值，在环上顺时针寻找到应选取的虚拟节点\n3、通过虚拟节点映射到真实节点\n1package consistenthash 2 3import ( 4\t\u0026#34;hash/crc32\u0026#34; 5\t\u0026#34;sort\u0026#34; 6\t\u0026#34;strconv\u0026#34; 7) 8 9type hash func(data []byte) uint32 10 11type CHash struct { 12\thash hash 13\treplicas int //the number of virtual nodes 14\tkeys []int 15\tvrMap map[int]string //mapping: virtual node-real node 16} 17 18func NewCHash(replicas int, hashFunc hash) *CHash { 19\tcHash := CHash{ 20\thash: hashFunc, 21\treplicas: replicas, 22\tvrMap: make(map[int]string), 23\t} 24 25\tif cHash.hash == nil { 26\tcHash.hash = crc32.ChecksumIEEE 27\t} 28 29\treturn \u0026amp;cHash 30} 31 32func (ch *CHash) Add(keys ...string) { 33\tfor _, key := range keys { 34\tfor i := 0; i \u0026lt; ch.replicas; i++ { 35\thashData := []byte(strconv.Itoa(i) + key) 36\thash := int(ch.hash(hashData)) 37\tch.keys = append(ch.keys, hash) 38\tch.vrMap[hash] = key 39\t} 40\t} 41 42\tsort.Ints(ch.keys) 43} 44 45func (ch *CHash) Get(key string) string { 46\tif ch.keys == nil { 47\treturn \u0026#34;\u0026#34; 48\t} 49 50\thash := int(ch.hash([]byte(key))) 51\tindex := sort.Search(len(ch.keys), func(i int) bool { 52\treturn ch.keys[i] \u0026gt;= hash 53\t}) 54 55\treturn ch.vrMap[ch.keys[index%len(ch.keys)]] 56} ","date":"2020-09-11","permalink":"https://why9661.github.io/myblog/posts/algorithm/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/","series":null,"tags":["负载均衡"],"title":"一致性哈希"},{"categories":["algorithm"],"content":"普通轮询 1package roundrobin 2 3type RoundRobin struct { 4 curIndex int 5 nodes []string 6} 7 8func NewRoundRobin() *RoundRobin { 9 return \u0026amp;RoundRobin{} 10} 11 12func (rrb *RoundRobin) Add(keys ...string) { 13 for _, key := range keys { 14 rrb.nodes = append(rrb.nodes, key) 15 } 16} 17 18func (rrb *RoundRobin) Get() string { 19 rrb.curIndex++ 20 rrb.curIndex = rrb.curIndex % len(rrb.nodes) 21 return rrb.nodes[rrb.curIndex] 22} 平滑加权轮询 每个节点有3种权重：\nWeight：配置权重\nCurrentWeight：当前权重\nEffectiveWeight：有效权重\n初始化一个节点时配置权重=当前权重=有效权重\nTotalWeight：所有节点的总权重（有效权重）\n算法步骤：\n1、遍历所有节点，设置当前节点的CurrentWeight=CurrentWeight+EffectiveWegiht\n2、选取CurrentWeight最大的节点。\n2、被选取的节点CurrentWeight=CurrentWeight-TotalWeight\n在遍历过程中计算出TotalWeight\n1package weightroundrobin 2 3type WeightRoundRobin struct { 4 nodes []*Node 5} 6 7type Node struct { 8 weight int 9 curWeight int 10 effectiveWeight int 11 key string 12} 13 14func NewWeightRoundRobin() *WeightRoundRobin { 15 return \u0026amp;WeightRoundRobin{} 16} 17 18func newNode(key string, weight int) *Node { 19 node := Node{ 20 weight: weight, 21 curWeight: weight, 22 effectiveWeight: weight, 23 key: key, 24 } 25 26 return \u0026amp;node 27} 28 29func (wrrb *WeightRoundRobin) Add(key string, weight int) { 30 node := newNode(key, weight) 31 32 wrrb.nodes = append(wrrb.nodes, node) 33} 34 35func (wrrb *WeightRoundRobin) Get() string { 36 totalWeight := 0 37 38 var maxCurWeightNode *Node 39 40 for _, node := range wrrb.nodes { 41 totalWeight += node.effectiveWeight 42 43 node.curWeight += node.effectiveWeight 44 45 if maxCurWeightNode == nil || node.curWeight \u0026gt; maxCurWeightNode.curWeight { 46 maxCurWeightNode = node 47 } 48 } 49 50 maxCurWeightNode.curWeight -= totalWeight 51 52 return maxCurWeightNode.key 53} ","date":"2020-09-02","permalink":"https://why9661.github.io/myblog/posts/algorithm/%E8%BD%AE%E8%AF%A2/","series":null,"tags":["负载均衡"],"title":"轮询"},{"categories":["Golang"],"content":"make和new有哪些不同？\n  make仅用于slice、map、channel三种类型的创建，返回的是所创建类型本身。\nnew可用于任意类型的创建，返回的是指向所创建类型的指针。\n  make创建slice、map、channel时会初始化内部数据结构，如slice的创建，会分配底层数组(Data)、初始化长度（Len）、初始化容量（Cap）。\nnew不会对内部数据结构进行初始化。\n  关于make和new创建的变量是分配在堆上还是在栈上，需要进行逃逸分析，这和其它一些语言的new分配在堆上不同。\n ","date":"2020-06-05","permalink":"https://why9661.github.io/myblog/posts/golang/make%E5%92%8Cnew/","series":null,"tags":["Golang"],"title":"Make和new"}]