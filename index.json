[{"categories":null,"content":" title = \u0026ldquo;一致性哈希\u0026rdquo; description = \u0026quot;\u0026quot; date = 2021-08-02T15:14:23+08:00 comment = true toc = true categories = [ \u0026ldquo;算法\u0026rdquo; ] tags = [ \u0026ldquo;负载均衡\u0026rdquo; ]\n为什么要使用一致性哈希？\n 普通的基于模运算的哈希算法会因为节点数目的变化而容易引起缓存雪崩（缓存在同一时刻全部失效，造成瞬时DB请求量大，压力骤增）。\n一致性哈希算法将 key 和节点映射到 2^32 的空间中，将这个数字首尾相连，形成一个环。\n①计算节点/机器(通常使用节点的名称、编号和 IP 地址)的哈希值，放置在环上。\n②计算key的哈希值放置在环上，顺时针寻找到的第一个节点，就是应选取的节点/机器。\n对于一致性哈希可能产生的数据倾斜的问题，可以引入“虚拟节点”：\n1、将虚拟节点的哈希值映射在环上\n2、计算key的哈希值，在环上顺时针寻找到应选取的虚拟节点\n3、通过虚拟节点映射到真实节点\nGolang实现\n1package consistenthash 2 3import ( 4\t\u0026#34;hash/crc32\u0026#34; 5\t\u0026#34;sort\u0026#34; 6\t\u0026#34;strconv\u0026#34; 7) 8 9type hash func(data []byte) uint32 // hash function 10 11type CHash struct { 12\thash hash 13\treplicas int //the number of virtual nodes 14\tkeys []int 15\tvrMap map[int]string // (virtual node)-(real node) 16} 17 18func NewCHash(replicas int, hashFunc hash) *CHash { 19\tcHash := CHash{ 20\thash: hashFunc, 21\treplicas: replicas, 22\tvrMap: make(map[int]string), 23\t} 24 25\tif cHash.hash == nil { 26\tcHash.hash = crc32.ChecksumIEEE 27\t} 28 29\treturn \u0026amp;cHash 30} 31 32func (ch *CHash) Add(keys ...string) { 33\tfor _, key := range keys { 34\tfor i := 0; i \u0026lt; ch.replicas; i++ { 35\thashData := []byte(strconv.Itoa(i) + key) 36\thash := int(ch.hash(hashData)) 37\tch.keys = append(ch.keys, hash) 38\tch.vrMap[hash] = key 39\t} 40\t} 41 42\tsort.Ints(ch.keys) 43} 44 45func (ch *CHash) Get(key string) string { 46\tif ch.keys == nil { 47\treturn \u0026#34;\u0026#34; 48\t} 49 50\thash := int(ch.hash([]byte(key))) 51\tindex := sort.Search(len(ch.keys), func(i int) bool { 52\treturn ch.keys[i] \u0026gt;= hash 53\t}) 54 55\treturn ch.vrMap[ch.keys[index%len(ch.keys)]] 56} 57 ","date":"0001-01-01","permalink":"https://why9661.github.io/myblog/posts/%E7%AE%97%E6%B3%95/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/","series":null,"tags":null,"title":""}]